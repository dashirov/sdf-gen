# Do not modify this file!
# Automatically generated by sdf-gen.

upstream service {
  server unix:/tmp/nginx.socket fail_timeout=0;
}

map $request_method $conjur_privilege {
  default update;
  GET read;
  OPTIONS read;
  HEAD read;
  POST create;
}

# create a cache zone for conjur-auth; 1M for keys should be plenty
proxy_cache_path /tmp/conjur-auth keys_zone=conjur-auth:1M inactive=480;

server {
  listen 80;
  server_name _;
  keepalive_timeout 5;

  location / {
    auth_request /conjur-authn;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header Host $http_host;
    proxy_redirect off;
    proxy_pass http://service;
  }

  location = /conjur-authn {
    internal;
    proxy_method GET;
    
    proxy_ssl_verify on;
    proxy_ssl_trusted_certificate /etc/conjur.pem;
    
    proxy_pass https://conjur/authz/demo/resources/webservice/production/asgard/?check=true&privilege=$conjur_privilege;
    proxy_intercept_errors on;
    proxy_next_upstream error timeout http_403;
    proxy_pass_request_body off;
    proxy_set_header Content-Length "";
    proxy_set_header X-Original-URI $request_uri;

    # To avoid storing the authentication tokens plaintext in cache, use
    # a hash. To avoid any potential hash collision attacks, do a hmac with
    # a randomly pregenerated key, effectively peppering the hash.
    set_hmac_sha1 $conjur_auth_key 3ad3a46ceb69706dfccb4640f561a855 $http_authorization;
    proxy_cache_key "$conjur_privilege $conjur_auth_key";

    proxy_cache conjur-auth; # the cache zone

    # hold other (duplicate) requests while one is running
    proxy_cache_lock on;

    # cache permits for 8 minutes
    proxy_cache_valid 204 8m;

    # cache other responses for 8 seconds
    proxy_cache_valid any 8s;

    # ignore the cache-control header (otherwise it wouldn't be cacheable)
    proxy_ignore_headers Cache-Control;
  }
}

